// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: JointState.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_JointState_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_JointState_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_JointState_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_JointState_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_JointState_2eproto;
namespace tutorial {
class JointState;
struct JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class JointTrajectory;
struct JointTrajectoryDefaultTypeInternal;
extern JointTrajectoryDefaultTypeInternal _JointTrajectory_default_instance_;
class JointTrajectoryPoint;
struct JointTrajectoryPointDefaultTypeInternal;
extern JointTrajectoryPointDefaultTypeInternal _JointTrajectoryPoint_default_instance_;
class RobotData;
struct RobotDataDefaultTypeInternal;
extern RobotDataDefaultTypeInternal _RobotData_default_instance_;
class TaskCommand;
struct TaskCommandDefaultTypeInternal;
extern TaskCommandDefaultTypeInternal _TaskCommand_default_instance_;
class TaskCommandItem;
struct TaskCommandItemDefaultTypeInternal;
extern TaskCommandItemDefaultTypeInternal _TaskCommandItem_default_instance_;
class TaskOder;
struct TaskOderDefaultTypeInternal;
extern TaskOderDefaultTypeInternal _TaskOder_default_instance_;
class TaskStatus;
struct TaskStatusDefaultTypeInternal;
extern TaskStatusDefaultTypeInternal _TaskStatus_default_instance_;
}  // namespace tutorial
PROTOBUF_NAMESPACE_OPEN
template<> ::tutorial::JointState* Arena::CreateMaybeMessage<::tutorial::JointState>(Arena*);
template<> ::tutorial::JointTrajectory* Arena::CreateMaybeMessage<::tutorial::JointTrajectory>(Arena*);
template<> ::tutorial::JointTrajectoryPoint* Arena::CreateMaybeMessage<::tutorial::JointTrajectoryPoint>(Arena*);
template<> ::tutorial::RobotData* Arena::CreateMaybeMessage<::tutorial::RobotData>(Arena*);
template<> ::tutorial::TaskCommand* Arena::CreateMaybeMessage<::tutorial::TaskCommand>(Arena*);
template<> ::tutorial::TaskCommandItem* Arena::CreateMaybeMessage<::tutorial::TaskCommandItem>(Arena*);
template<> ::tutorial::TaskOder* Arena::CreateMaybeMessage<::tutorial::TaskOder>(Arena*);
template<> ::tutorial::TaskStatus* Arena::CreateMaybeMessage<::tutorial::TaskStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tutorial {

enum MsgType : int {
  JOINT_STATE = 0,
  JOINT_TRAJECTORY = 1,
  TASK_CMD = 2,
  TASK_ODER = 3,
  TASK_STATUS = 4,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = JOINT_STATE;
constexpr MsgType MsgType_MAX = TASK_STATUS;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum STATUS : int {
  Non = 0,
  W = 1,
  RUN_TO_START = 2,
  STOP_START_POINT = 3,
  RUN_TO_GOAL = 4,
  STOP_GOAL_POINT = 5,
  RUN_C = 6,
  STOP_C = 7,
  Finish = 8,
  NOP = 9,
  STATUS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  STATUS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool STATUS_IsValid(int value);
constexpr STATUS STATUS_MIN = Non;
constexpr STATUS STATUS_MAX = NOP;
constexpr int STATUS_ARRAYSIZE = STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* STATUS_descriptor();
template<typename T>
inline const std::string& STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    STATUS_descriptor(), enum_t_value);
}
inline bool STATUS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<STATUS>(
    STATUS_descriptor(), name, value);
}
enum DEVICE_STATUS : int {
  Idle = 0,
  Running = 1,
  No = 2,
  DEVICE_STATUS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DEVICE_STATUS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DEVICE_STATUS_IsValid(int value);
constexpr DEVICE_STATUS DEVICE_STATUS_MIN = Idle;
constexpr DEVICE_STATUS DEVICE_STATUS_MAX = No;
constexpr int DEVICE_STATUS_ARRAYSIZE = DEVICE_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DEVICE_STATUS_descriptor();
template<typename T>
inline const std::string& DEVICE_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DEVICE_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DEVICE_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DEVICE_STATUS_descriptor(), enum_t_value);
}
inline bool DEVICE_STATUS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DEVICE_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DEVICE_STATUS>(
    DEVICE_STATUS_descriptor(), name, value);
}
// ===================================================================

class RobotData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.RobotData) */ {
 public:
  inline RobotData() : RobotData(nullptr) {}
  ~RobotData() override;
  explicit PROTOBUF_CONSTEXPR RobotData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotData(const RobotData& from);
  RobotData(RobotData&& from) noexcept
    : RobotData() {
    *this = ::std::move(from);
  }

  inline RobotData& operator=(const RobotData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotData& operator=(RobotData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotData& default_instance() {
    return *internal_default_instance();
  }
  enum DeteilCase {
    kJointState = 3,
    kTrajectory = 4,
    kTaskCmd = 5,
    kTaskOder = 6,
    kTaskSta = 7,
    DETEIL_NOT_SET = 0,
  };

  static inline const RobotData* internal_default_instance() {
    return reinterpret_cast<const RobotData*>(
               &_RobotData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RobotData& a, RobotData& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RobotData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.RobotData";
  }
  protected:
  explicit RobotData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kHeatbeatFieldNumber = 8,
    kJointStateFieldNumber = 3,
    kTrajectoryFieldNumber = 4,
    kTaskCmdFieldNumber = 5,
    kTaskOderFieldNumber = 6,
    kTaskStaFieldNumber = 7,
  };
  // string robotName = 1;
  void clear_robotname();
  const std::string& robotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robotname();
  PROTOBUF_NODISCARD std::string* release_robotname();
  void set_allocated_robotname(std::string* robotname);
  private:
  const std::string& _internal_robotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotname(const std::string& value);
  std::string* _internal_mutable_robotname();
  public:

  // .tutorial.MsgType type = 2;
  void clear_type();
  ::tutorial::MsgType type() const;
  void set_type(::tutorial::MsgType value);
  private:
  ::tutorial::MsgType _internal_type() const;
  void _internal_set_type(::tutorial::MsgType value);
  public:

  // int32 heatbeat = 8;
  void clear_heatbeat();
  int32_t heatbeat() const;
  void set_heatbeat(int32_t value);
  private:
  int32_t _internal_heatbeat() const;
  void _internal_set_heatbeat(int32_t value);
  public:

  // .tutorial.JointState jointState = 3;
  bool has_jointstate() const;
  private:
  bool _internal_has_jointstate() const;
  public:
  void clear_jointstate();
  const ::tutorial::JointState& jointstate() const;
  PROTOBUF_NODISCARD ::tutorial::JointState* release_jointstate();
  ::tutorial::JointState* mutable_jointstate();
  void set_allocated_jointstate(::tutorial::JointState* jointstate);
  private:
  const ::tutorial::JointState& _internal_jointstate() const;
  ::tutorial::JointState* _internal_mutable_jointstate();
  public:
  void unsafe_arena_set_allocated_jointstate(
      ::tutorial::JointState* jointstate);
  ::tutorial::JointState* unsafe_arena_release_jointstate();

  // .tutorial.JointTrajectory trajectory = 4;
  bool has_trajectory() const;
  private:
  bool _internal_has_trajectory() const;
  public:
  void clear_trajectory();
  const ::tutorial::JointTrajectory& trajectory() const;
  PROTOBUF_NODISCARD ::tutorial::JointTrajectory* release_trajectory();
  ::tutorial::JointTrajectory* mutable_trajectory();
  void set_allocated_trajectory(::tutorial::JointTrajectory* trajectory);
  private:
  const ::tutorial::JointTrajectory& _internal_trajectory() const;
  ::tutorial::JointTrajectory* _internal_mutable_trajectory();
  public:
  void unsafe_arena_set_allocated_trajectory(
      ::tutorial::JointTrajectory* trajectory);
  ::tutorial::JointTrajectory* unsafe_arena_release_trajectory();

  // .tutorial.TaskCommand taskCmd = 5;
  bool has_taskcmd() const;
  private:
  bool _internal_has_taskcmd() const;
  public:
  void clear_taskcmd();
  const ::tutorial::TaskCommand& taskcmd() const;
  PROTOBUF_NODISCARD ::tutorial::TaskCommand* release_taskcmd();
  ::tutorial::TaskCommand* mutable_taskcmd();
  void set_allocated_taskcmd(::tutorial::TaskCommand* taskcmd);
  private:
  const ::tutorial::TaskCommand& _internal_taskcmd() const;
  ::tutorial::TaskCommand* _internal_mutable_taskcmd();
  public:
  void unsafe_arena_set_allocated_taskcmd(
      ::tutorial::TaskCommand* taskcmd);
  ::tutorial::TaskCommand* unsafe_arena_release_taskcmd();

  // .tutorial.TaskOder taskOder = 6;
  bool has_taskoder() const;
  private:
  bool _internal_has_taskoder() const;
  public:
  void clear_taskoder();
  const ::tutorial::TaskOder& taskoder() const;
  PROTOBUF_NODISCARD ::tutorial::TaskOder* release_taskoder();
  ::tutorial::TaskOder* mutable_taskoder();
  void set_allocated_taskoder(::tutorial::TaskOder* taskoder);
  private:
  const ::tutorial::TaskOder& _internal_taskoder() const;
  ::tutorial::TaskOder* _internal_mutable_taskoder();
  public:
  void unsafe_arena_set_allocated_taskoder(
      ::tutorial::TaskOder* taskoder);
  ::tutorial::TaskOder* unsafe_arena_release_taskoder();

  // .tutorial.TaskStatus taskSta = 7;
  bool has_tasksta() const;
  private:
  bool _internal_has_tasksta() const;
  public:
  void clear_tasksta();
  const ::tutorial::TaskStatus& tasksta() const;
  PROTOBUF_NODISCARD ::tutorial::TaskStatus* release_tasksta();
  ::tutorial::TaskStatus* mutable_tasksta();
  void set_allocated_tasksta(::tutorial::TaskStatus* tasksta);
  private:
  const ::tutorial::TaskStatus& _internal_tasksta() const;
  ::tutorial::TaskStatus* _internal_mutable_tasksta();
  public:
  void unsafe_arena_set_allocated_tasksta(
      ::tutorial::TaskStatus* tasksta);
  ::tutorial::TaskStatus* unsafe_arena_release_tasksta();

  void clear_Deteil();
  DeteilCase Deteil_case() const;
  // @@protoc_insertion_point(class_scope:tutorial.RobotData)
 private:
  class _Internal;
  void set_has_jointstate();
  void set_has_trajectory();
  void set_has_taskcmd();
  void set_has_taskoder();
  void set_has_tasksta();

  inline bool has_Deteil() const;
  inline void clear_has_Deteil();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robotname_;
  int type_;
  int32_t heatbeat_;
  union DeteilUnion {
    constexpr DeteilUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tutorial::JointState* jointstate_;
    ::tutorial::JointTrajectory* trajectory_;
    ::tutorial::TaskCommand* taskcmd_;
    ::tutorial::TaskOder* taskoder_;
    ::tutorial::TaskStatus* tasksta_;
  } Deteil_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_JointState_2eproto;
};
// -------------------------------------------------------------------

class JointState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.JointState) */ {
 public:
  inline JointState() : JointState(nullptr) {}
  ~JointState() override;
  explicit PROTOBUF_CONSTEXPR JointState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointState(const JointState& from);
  JointState(JointState&& from) noexcept
    : JointState() {
    *this = ::std::move(from);
  }

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointState& operator=(JointState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointState& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(JointState& a, JointState& b) {
    a.Swap(&b);
  }
  inline void Swap(JointState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JointState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.JointState";
  }
  protected:
  explicit JointState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 1,
    kVelocitiesFieldNumber = 2,
    kAccelerationsFieldNumber = 3,
  };
  // repeated float positions = 1;
  int positions_size() const;
  private:
  int _internal_positions_size() const;
  public:
  void clear_positions();
  private:
  float _internal_positions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_positions() const;
  void _internal_add_positions(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_positions();
  public:
  float positions(int index) const;
  void set_positions(int index, float value);
  void add_positions(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_positions();

  // repeated float velocities = 2;
  int velocities_size() const;
  private:
  int _internal_velocities_size() const;
  public:
  void clear_velocities();
  private:
  float _internal_velocities(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_velocities() const;
  void _internal_add_velocities(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_velocities();
  public:
  float velocities(int index) const;
  void set_velocities(int index, float value);
  void add_velocities(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      velocities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_velocities();

  // repeated float accelerations = 3;
  int accelerations_size() const;
  private:
  int _internal_accelerations_size() const;
  public:
  void clear_accelerations();
  private:
  float _internal_accelerations(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_accelerations() const;
  void _internal_add_accelerations(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_accelerations();
  public:
  float accelerations(int index) const;
  void set_accelerations(int index, float value);
  void add_accelerations(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      accelerations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_accelerations();

  // @@protoc_insertion_point(class_scope:tutorial.JointState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > positions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > velocities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > accelerations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_JointState_2eproto;
};
// -------------------------------------------------------------------

class JointTrajectoryPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.JointTrajectoryPoint) */ {
 public:
  inline JointTrajectoryPoint() : JointTrajectoryPoint(nullptr) {}
  ~JointTrajectoryPoint() override;
  explicit PROTOBUF_CONSTEXPR JointTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointTrajectoryPoint(const JointTrajectoryPoint& from);
  JointTrajectoryPoint(JointTrajectoryPoint&& from) noexcept
    : JointTrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline JointTrajectoryPoint& operator=(const JointTrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointTrajectoryPoint& operator=(JointTrajectoryPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointTrajectoryPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointTrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const JointTrajectoryPoint*>(
               &_JointTrajectoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(JointTrajectoryPoint& a, JointTrajectoryPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(JointTrajectoryPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointTrajectoryPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointTrajectoryPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointTrajectoryPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointTrajectoryPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JointTrajectoryPoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointTrajectoryPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.JointTrajectoryPoint";
  }
  protected:
  explicit JointTrajectoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 2,
    kVelocitiesFieldNumber = 3,
    kAccelerationsFieldNumber = 4,
    kTimeFieldNumber = 1,
  };
  // repeated float positions = 2;
  int positions_size() const;
  private:
  int _internal_positions_size() const;
  public:
  void clear_positions();
  private:
  float _internal_positions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_positions() const;
  void _internal_add_positions(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_positions();
  public:
  float positions(int index) const;
  void set_positions(int index, float value);
  void add_positions(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_positions();

  // repeated float velocities = 3;
  int velocities_size() const;
  private:
  int _internal_velocities_size() const;
  public:
  void clear_velocities();
  private:
  float _internal_velocities(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_velocities() const;
  void _internal_add_velocities(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_velocities();
  public:
  float velocities(int index) const;
  void set_velocities(int index, float value);
  void add_velocities(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      velocities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_velocities();

  // repeated float accelerations = 4;
  int accelerations_size() const;
  private:
  int _internal_accelerations_size() const;
  public:
  void clear_accelerations();
  private:
  float _internal_accelerations(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_accelerations() const;
  void _internal_add_accelerations(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_accelerations();
  public:
  float accelerations(int index) const;
  void set_accelerations(int index, float value);
  void add_accelerations(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      accelerations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_accelerations();

  // int32 time = 1;
  void clear_time();
  int32_t time() const;
  void set_time(int32_t value);
  private:
  int32_t _internal_time() const;
  void _internal_set_time(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.JointTrajectoryPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > positions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > velocities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > accelerations_;
  int32_t time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_JointState_2eproto;
};
// -------------------------------------------------------------------

class JointTrajectory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.JointTrajectory) */ {
 public:
  inline JointTrajectory() : JointTrajectory(nullptr) {}
  ~JointTrajectory() override;
  explicit PROTOBUF_CONSTEXPR JointTrajectory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JointTrajectory(const JointTrajectory& from);
  JointTrajectory(JointTrajectory&& from) noexcept
    : JointTrajectory() {
    *this = ::std::move(from);
  }

  inline JointTrajectory& operator=(const JointTrajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointTrajectory& operator=(JointTrajectory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JointTrajectory& default_instance() {
    return *internal_default_instance();
  }
  static inline const JointTrajectory* internal_default_instance() {
    return reinterpret_cast<const JointTrajectory*>(
               &_JointTrajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(JointTrajectory& a, JointTrajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(JointTrajectory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointTrajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JointTrajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JointTrajectory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JointTrajectory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JointTrajectory& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointTrajectory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.JointTrajectory";
  }
  protected:
  explicit JointTrajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kCountFieldNumber = 1,
  };
  // repeated .tutorial.JointTrajectoryPoint points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::tutorial::JointTrajectoryPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::JointTrajectoryPoint >*
      mutable_points();
  private:
  const ::tutorial::JointTrajectoryPoint& _internal_points(int index) const;
  ::tutorial::JointTrajectoryPoint* _internal_add_points();
  public:
  const ::tutorial::JointTrajectoryPoint& points(int index) const;
  ::tutorial::JointTrajectoryPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::JointTrajectoryPoint >&
      points() const;

  // int32 count = 1;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.JointTrajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::JointTrajectoryPoint > points_;
  int32_t count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_JointState_2eproto;
};
// -------------------------------------------------------------------

class TaskCommandItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.TaskCommandItem) */ {
 public:
  inline TaskCommandItem() : TaskCommandItem(nullptr) {}
  ~TaskCommandItem() override;
  explicit PROTOBUF_CONSTEXPR TaskCommandItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskCommandItem(const TaskCommandItem& from);
  TaskCommandItem(TaskCommandItem&& from) noexcept
    : TaskCommandItem() {
    *this = ::std::move(from);
  }

  inline TaskCommandItem& operator=(const TaskCommandItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskCommandItem& operator=(TaskCommandItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskCommandItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskCommandItem* internal_default_instance() {
    return reinterpret_cast<const TaskCommandItem*>(
               &_TaskCommandItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TaskCommandItem& a, TaskCommandItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskCommandItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskCommandItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskCommandItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskCommandItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskCommandItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskCommandItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskCommandItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.TaskCommandItem";
  }
  protected:
  explicit TaskCommandItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotNameFieldNumber = 1,
    kTaskNumFieldNumber = 2,
    kStartXFieldNumber = 3,
    kStartYFieldNumber = 4,
    kStartZFieldNumber = 5,
    kGoalXFieldNumber = 6,
    kGoalYFieldNumber = 7,
    kGoalZFieldNumber = 8,
    kGoal7FieldNumber = 9,
  };
  // string robotName = 1;
  void clear_robotname();
  const std::string& robotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robotname();
  PROTOBUF_NODISCARD std::string* release_robotname();
  void set_allocated_robotname(std::string* robotname);
  private:
  const std::string& _internal_robotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotname(const std::string& value);
  std::string* _internal_mutable_robotname();
  public:

  // int32 task_num = 2;
  void clear_task_num();
  int32_t task_num() const;
  void set_task_num(int32_t value);
  private:
  int32_t _internal_task_num() const;
  void _internal_set_task_num(int32_t value);
  public:

  // float startX = 3;
  void clear_startx();
  float startx() const;
  void set_startx(float value);
  private:
  float _internal_startx() const;
  void _internal_set_startx(float value);
  public:

  // float startY = 4;
  void clear_starty();
  float starty() const;
  void set_starty(float value);
  private:
  float _internal_starty() const;
  void _internal_set_starty(float value);
  public:

  // float startZ = 5;
  void clear_startz();
  float startz() const;
  void set_startz(float value);
  private:
  float _internal_startz() const;
  void _internal_set_startz(float value);
  public:

  // float goalX = 6;
  void clear_goalx();
  float goalx() const;
  void set_goalx(float value);
  private:
  float _internal_goalx() const;
  void _internal_set_goalx(float value);
  public:

  // float goalY = 7;
  void clear_goaly();
  float goaly() const;
  void set_goaly(float value);
  private:
  float _internal_goaly() const;
  void _internal_set_goaly(float value);
  public:

  // float goalZ = 8;
  void clear_goalz();
  float goalz() const;
  void set_goalz(float value);
  private:
  float _internal_goalz() const;
  void _internal_set_goalz(float value);
  public:

  // float goal7 = 9;
  void clear_goal7();
  float goal7() const;
  void set_goal7(float value);
  private:
  float _internal_goal7() const;
  void _internal_set_goal7(float value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.TaskCommandItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robotname_;
  int32_t task_num_;
  float startx_;
  float starty_;
  float startz_;
  float goalx_;
  float goaly_;
  float goalz_;
  float goal7_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_JointState_2eproto;
};
// -------------------------------------------------------------------

class TaskCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.TaskCommand) */ {
 public:
  inline TaskCommand() : TaskCommand(nullptr) {}
  ~TaskCommand() override;
  explicit PROTOBUF_CONSTEXPR TaskCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskCommand(const TaskCommand& from);
  TaskCommand(TaskCommand&& from) noexcept
    : TaskCommand() {
    *this = ::std::move(from);
  }

  inline TaskCommand& operator=(const TaskCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskCommand& operator=(TaskCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskCommand* internal_default_instance() {
    return reinterpret_cast<const TaskCommand*>(
               &_TaskCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TaskCommand& a, TaskCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.TaskCommand";
  }
  protected:
  explicit TaskCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .tutorial.TaskCommandItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::tutorial::TaskCommandItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::TaskCommandItem >*
      mutable_items();
  private:
  const ::tutorial::TaskCommandItem& _internal_items(int index) const;
  ::tutorial::TaskCommandItem* _internal_add_items();
  public:
  const ::tutorial::TaskCommandItem& items(int index) const;
  ::tutorial::TaskCommandItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::TaskCommandItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:tutorial.TaskCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::TaskCommandItem > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_JointState_2eproto;
};
// -------------------------------------------------------------------

class TaskOder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.TaskOder) */ {
 public:
  inline TaskOder() : TaskOder(nullptr) {}
  ~TaskOder() override;
  explicit PROTOBUF_CONSTEXPR TaskOder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskOder(const TaskOder& from);
  TaskOder(TaskOder&& from) noexcept
    : TaskOder() {
    *this = ::std::move(from);
  }

  inline TaskOder& operator=(const TaskOder& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskOder& operator=(TaskOder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskOder& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskOder* internal_default_instance() {
    return reinterpret_cast<const TaskOder*>(
               &_TaskOder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TaskOder& a, TaskOder& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskOder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskOder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskOder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskOder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskOder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskOder& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskOder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.TaskOder";
  }
  protected:
  explicit TaskOder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotNameFieldNumber = 1,
    kStopoderFieldNumber = 2,
    kRunoderFieldNumber = 3,
    kTestoderFieldNumber = 4,
  };
  // string robotName = 1;
  void clear_robotname();
  const std::string& robotname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_robotname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_robotname();
  PROTOBUF_NODISCARD std::string* release_robotname();
  void set_allocated_robotname(std::string* robotname);
  private:
  const std::string& _internal_robotname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_robotname(const std::string& value);
  std::string* _internal_mutable_robotname();
  public:

  // bool stopoder = 2;
  void clear_stopoder();
  bool stopoder() const;
  void set_stopoder(bool value);
  private:
  bool _internal_stopoder() const;
  void _internal_set_stopoder(bool value);
  public:

  // bool runoder = 3;
  void clear_runoder();
  bool runoder() const;
  void set_runoder(bool value);
  private:
  bool _internal_runoder() const;
  void _internal_set_runoder(bool value);
  public:

  // bool testoder = 4;
  void clear_testoder();
  bool testoder() const;
  void set_testoder(bool value);
  private:
  bool _internal_testoder() const;
  void _internal_set_testoder(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.TaskOder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr robotname_;
  bool stopoder_;
  bool runoder_;
  bool testoder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_JointState_2eproto;
};
// -------------------------------------------------------------------

class TaskStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.TaskStatus) */ {
 public:
  inline TaskStatus() : TaskStatus(nullptr) {}
  ~TaskStatus() override;
  explicit PROTOBUF_CONSTEXPR TaskStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskStatus(const TaskStatus& from);
  TaskStatus(TaskStatus&& from) noexcept
    : TaskStatus() {
    *this = ::std::move(from);
  }

  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskStatus& operator=(TaskStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskStatus* internal_default_instance() {
    return reinterpret_cast<const TaskStatus*>(
               &_TaskStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TaskStatus& a, TaskStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.TaskStatus";
  }
  protected:
  explicit TaskStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskNumFieldNumber = 1,
    kStatusFieldNumber = 2,
    kDeviceNumFieldNumber = 3,
  };
  // int32 task_num = 1;
  void clear_task_num();
  int32_t task_num() const;
  void set_task_num(int32_t value);
  private:
  int32_t _internal_task_num() const;
  void _internal_set_task_num(int32_t value);
  public:

  // .tutorial.STATUS status = 2;
  void clear_status();
  ::tutorial::STATUS status() const;
  void set_status(::tutorial::STATUS value);
  private:
  ::tutorial::STATUS _internal_status() const;
  void _internal_set_status(::tutorial::STATUS value);
  public:

  // int32 device_num = 3;
  void clear_device_num();
  int32_t device_num() const;
  void set_device_num(int32_t value);
  private:
  int32_t _internal_device_num() const;
  void _internal_set_device_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.TaskStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t task_num_;
  int status_;
  int32_t device_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_JointState_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotData

// string robotName = 1;
inline void RobotData::clear_robotname() {
  robotname_.ClearToEmpty();
}
inline const std::string& RobotData::robotname() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.robotName)
  return _internal_robotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RobotData::set_robotname(ArgT0&& arg0, ArgT... args) {
 
 robotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.RobotData.robotName)
}
inline std::string* RobotData::mutable_robotname() {
  std::string* _s = _internal_mutable_robotname();
  // @@protoc_insertion_point(field_mutable:tutorial.RobotData.robotName)
  return _s;
}
inline const std::string& RobotData::_internal_robotname() const {
  return robotname_.Get();
}
inline void RobotData::_internal_set_robotname(const std::string& value) {
  
  robotname_.Set(value, GetArenaForAllocation());
}
inline std::string* RobotData::_internal_mutable_robotname() {
  
  return robotname_.Mutable(GetArenaForAllocation());
}
inline std::string* RobotData::release_robotname() {
  // @@protoc_insertion_point(field_release:tutorial.RobotData.robotName)
  return robotname_.Release();
}
inline void RobotData::set_allocated_robotname(std::string* robotname) {
  if (robotname != nullptr) {
    
  } else {
    
  }
  robotname_.SetAllocated(robotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robotname_.IsDefault()) {
    robotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.RobotData.robotName)
}

// .tutorial.MsgType type = 2;
inline void RobotData::clear_type() {
  type_ = 0;
}
inline ::tutorial::MsgType RobotData::_internal_type() const {
  return static_cast< ::tutorial::MsgType >(type_);
}
inline ::tutorial::MsgType RobotData::type() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.type)
  return _internal_type();
}
inline void RobotData::_internal_set_type(::tutorial::MsgType value) {
  
  type_ = value;
}
inline void RobotData::set_type(::tutorial::MsgType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tutorial.RobotData.type)
}

// .tutorial.JointState jointState = 3;
inline bool RobotData::_internal_has_jointstate() const {
  return Deteil_case() == kJointState;
}
inline bool RobotData::has_jointstate() const {
  return _internal_has_jointstate();
}
inline void RobotData::set_has_jointstate() {
  _oneof_case_[0] = kJointState;
}
inline void RobotData::clear_jointstate() {
  if (_internal_has_jointstate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Deteil_.jointstate_;
    }
    clear_has_Deteil();
  }
}
inline ::tutorial::JointState* RobotData::release_jointstate() {
  // @@protoc_insertion_point(field_release:tutorial.RobotData.jointState)
  if (_internal_has_jointstate()) {
    clear_has_Deteil();
    ::tutorial::JointState* temp = Deteil_.jointstate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Deteil_.jointstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tutorial::JointState& RobotData::_internal_jointstate() const {
  return _internal_has_jointstate()
      ? *Deteil_.jointstate_
      : reinterpret_cast< ::tutorial::JointState&>(::tutorial::_JointState_default_instance_);
}
inline const ::tutorial::JointState& RobotData::jointstate() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.jointState)
  return _internal_jointstate();
}
inline ::tutorial::JointState* RobotData::unsafe_arena_release_jointstate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tutorial.RobotData.jointState)
  if (_internal_has_jointstate()) {
    clear_has_Deteil();
    ::tutorial::JointState* temp = Deteil_.jointstate_;
    Deteil_.jointstate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotData::unsafe_arena_set_allocated_jointstate(::tutorial::JointState* jointstate) {
  clear_Deteil();
  if (jointstate) {
    set_has_jointstate();
    Deteil_.jointstate_ = jointstate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.RobotData.jointState)
}
inline ::tutorial::JointState* RobotData::_internal_mutable_jointstate() {
  if (!_internal_has_jointstate()) {
    clear_Deteil();
    set_has_jointstate();
    Deteil_.jointstate_ = CreateMaybeMessage< ::tutorial::JointState >(GetArenaForAllocation());
  }
  return Deteil_.jointstate_;
}
inline ::tutorial::JointState* RobotData::mutable_jointstate() {
  ::tutorial::JointState* _msg = _internal_mutable_jointstate();
  // @@protoc_insertion_point(field_mutable:tutorial.RobotData.jointState)
  return _msg;
}

// .tutorial.JointTrajectory trajectory = 4;
inline bool RobotData::_internal_has_trajectory() const {
  return Deteil_case() == kTrajectory;
}
inline bool RobotData::has_trajectory() const {
  return _internal_has_trajectory();
}
inline void RobotData::set_has_trajectory() {
  _oneof_case_[0] = kTrajectory;
}
inline void RobotData::clear_trajectory() {
  if (_internal_has_trajectory()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Deteil_.trajectory_;
    }
    clear_has_Deteil();
  }
}
inline ::tutorial::JointTrajectory* RobotData::release_trajectory() {
  // @@protoc_insertion_point(field_release:tutorial.RobotData.trajectory)
  if (_internal_has_trajectory()) {
    clear_has_Deteil();
    ::tutorial::JointTrajectory* temp = Deteil_.trajectory_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Deteil_.trajectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tutorial::JointTrajectory& RobotData::_internal_trajectory() const {
  return _internal_has_trajectory()
      ? *Deteil_.trajectory_
      : reinterpret_cast< ::tutorial::JointTrajectory&>(::tutorial::_JointTrajectory_default_instance_);
}
inline const ::tutorial::JointTrajectory& RobotData::trajectory() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.trajectory)
  return _internal_trajectory();
}
inline ::tutorial::JointTrajectory* RobotData::unsafe_arena_release_trajectory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tutorial.RobotData.trajectory)
  if (_internal_has_trajectory()) {
    clear_has_Deteil();
    ::tutorial::JointTrajectory* temp = Deteil_.trajectory_;
    Deteil_.trajectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotData::unsafe_arena_set_allocated_trajectory(::tutorial::JointTrajectory* trajectory) {
  clear_Deteil();
  if (trajectory) {
    set_has_trajectory();
    Deteil_.trajectory_ = trajectory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.RobotData.trajectory)
}
inline ::tutorial::JointTrajectory* RobotData::_internal_mutable_trajectory() {
  if (!_internal_has_trajectory()) {
    clear_Deteil();
    set_has_trajectory();
    Deteil_.trajectory_ = CreateMaybeMessage< ::tutorial::JointTrajectory >(GetArenaForAllocation());
  }
  return Deteil_.trajectory_;
}
inline ::tutorial::JointTrajectory* RobotData::mutable_trajectory() {
  ::tutorial::JointTrajectory* _msg = _internal_mutable_trajectory();
  // @@protoc_insertion_point(field_mutable:tutorial.RobotData.trajectory)
  return _msg;
}

// .tutorial.TaskCommand taskCmd = 5;
inline bool RobotData::_internal_has_taskcmd() const {
  return Deteil_case() == kTaskCmd;
}
inline bool RobotData::has_taskcmd() const {
  return _internal_has_taskcmd();
}
inline void RobotData::set_has_taskcmd() {
  _oneof_case_[0] = kTaskCmd;
}
inline void RobotData::clear_taskcmd() {
  if (_internal_has_taskcmd()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Deteil_.taskcmd_;
    }
    clear_has_Deteil();
  }
}
inline ::tutorial::TaskCommand* RobotData::release_taskcmd() {
  // @@protoc_insertion_point(field_release:tutorial.RobotData.taskCmd)
  if (_internal_has_taskcmd()) {
    clear_has_Deteil();
    ::tutorial::TaskCommand* temp = Deteil_.taskcmd_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Deteil_.taskcmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tutorial::TaskCommand& RobotData::_internal_taskcmd() const {
  return _internal_has_taskcmd()
      ? *Deteil_.taskcmd_
      : reinterpret_cast< ::tutorial::TaskCommand&>(::tutorial::_TaskCommand_default_instance_);
}
inline const ::tutorial::TaskCommand& RobotData::taskcmd() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.taskCmd)
  return _internal_taskcmd();
}
inline ::tutorial::TaskCommand* RobotData::unsafe_arena_release_taskcmd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tutorial.RobotData.taskCmd)
  if (_internal_has_taskcmd()) {
    clear_has_Deteil();
    ::tutorial::TaskCommand* temp = Deteil_.taskcmd_;
    Deteil_.taskcmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotData::unsafe_arena_set_allocated_taskcmd(::tutorial::TaskCommand* taskcmd) {
  clear_Deteil();
  if (taskcmd) {
    set_has_taskcmd();
    Deteil_.taskcmd_ = taskcmd;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.RobotData.taskCmd)
}
inline ::tutorial::TaskCommand* RobotData::_internal_mutable_taskcmd() {
  if (!_internal_has_taskcmd()) {
    clear_Deteil();
    set_has_taskcmd();
    Deteil_.taskcmd_ = CreateMaybeMessage< ::tutorial::TaskCommand >(GetArenaForAllocation());
  }
  return Deteil_.taskcmd_;
}
inline ::tutorial::TaskCommand* RobotData::mutable_taskcmd() {
  ::tutorial::TaskCommand* _msg = _internal_mutable_taskcmd();
  // @@protoc_insertion_point(field_mutable:tutorial.RobotData.taskCmd)
  return _msg;
}

// .tutorial.TaskOder taskOder = 6;
inline bool RobotData::_internal_has_taskoder() const {
  return Deteil_case() == kTaskOder;
}
inline bool RobotData::has_taskoder() const {
  return _internal_has_taskoder();
}
inline void RobotData::set_has_taskoder() {
  _oneof_case_[0] = kTaskOder;
}
inline void RobotData::clear_taskoder() {
  if (_internal_has_taskoder()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Deteil_.taskoder_;
    }
    clear_has_Deteil();
  }
}
inline ::tutorial::TaskOder* RobotData::release_taskoder() {
  // @@protoc_insertion_point(field_release:tutorial.RobotData.taskOder)
  if (_internal_has_taskoder()) {
    clear_has_Deteil();
    ::tutorial::TaskOder* temp = Deteil_.taskoder_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Deteil_.taskoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tutorial::TaskOder& RobotData::_internal_taskoder() const {
  return _internal_has_taskoder()
      ? *Deteil_.taskoder_
      : reinterpret_cast< ::tutorial::TaskOder&>(::tutorial::_TaskOder_default_instance_);
}
inline const ::tutorial::TaskOder& RobotData::taskoder() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.taskOder)
  return _internal_taskoder();
}
inline ::tutorial::TaskOder* RobotData::unsafe_arena_release_taskoder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tutorial.RobotData.taskOder)
  if (_internal_has_taskoder()) {
    clear_has_Deteil();
    ::tutorial::TaskOder* temp = Deteil_.taskoder_;
    Deteil_.taskoder_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotData::unsafe_arena_set_allocated_taskoder(::tutorial::TaskOder* taskoder) {
  clear_Deteil();
  if (taskoder) {
    set_has_taskoder();
    Deteil_.taskoder_ = taskoder;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.RobotData.taskOder)
}
inline ::tutorial::TaskOder* RobotData::_internal_mutable_taskoder() {
  if (!_internal_has_taskoder()) {
    clear_Deteil();
    set_has_taskoder();
    Deteil_.taskoder_ = CreateMaybeMessage< ::tutorial::TaskOder >(GetArenaForAllocation());
  }
  return Deteil_.taskoder_;
}
inline ::tutorial::TaskOder* RobotData::mutable_taskoder() {
  ::tutorial::TaskOder* _msg = _internal_mutable_taskoder();
  // @@protoc_insertion_point(field_mutable:tutorial.RobotData.taskOder)
  return _msg;
}

// .tutorial.TaskStatus taskSta = 7;
inline bool RobotData::_internal_has_tasksta() const {
  return Deteil_case() == kTaskSta;
}
inline bool RobotData::has_tasksta() const {
  return _internal_has_tasksta();
}
inline void RobotData::set_has_tasksta() {
  _oneof_case_[0] = kTaskSta;
}
inline void RobotData::clear_tasksta() {
  if (_internal_has_tasksta()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Deteil_.tasksta_;
    }
    clear_has_Deteil();
  }
}
inline ::tutorial::TaskStatus* RobotData::release_tasksta() {
  // @@protoc_insertion_point(field_release:tutorial.RobotData.taskSta)
  if (_internal_has_tasksta()) {
    clear_has_Deteil();
    ::tutorial::TaskStatus* temp = Deteil_.tasksta_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Deteil_.tasksta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tutorial::TaskStatus& RobotData::_internal_tasksta() const {
  return _internal_has_tasksta()
      ? *Deteil_.tasksta_
      : reinterpret_cast< ::tutorial::TaskStatus&>(::tutorial::_TaskStatus_default_instance_);
}
inline const ::tutorial::TaskStatus& RobotData::tasksta() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.taskSta)
  return _internal_tasksta();
}
inline ::tutorial::TaskStatus* RobotData::unsafe_arena_release_tasksta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tutorial.RobotData.taskSta)
  if (_internal_has_tasksta()) {
    clear_has_Deteil();
    ::tutorial::TaskStatus* temp = Deteil_.tasksta_;
    Deteil_.tasksta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotData::unsafe_arena_set_allocated_tasksta(::tutorial::TaskStatus* tasksta) {
  clear_Deteil();
  if (tasksta) {
    set_has_tasksta();
    Deteil_.tasksta_ = tasksta;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.RobotData.taskSta)
}
inline ::tutorial::TaskStatus* RobotData::_internal_mutable_tasksta() {
  if (!_internal_has_tasksta()) {
    clear_Deteil();
    set_has_tasksta();
    Deteil_.tasksta_ = CreateMaybeMessage< ::tutorial::TaskStatus >(GetArenaForAllocation());
  }
  return Deteil_.tasksta_;
}
inline ::tutorial::TaskStatus* RobotData::mutable_tasksta() {
  ::tutorial::TaskStatus* _msg = _internal_mutable_tasksta();
  // @@protoc_insertion_point(field_mutable:tutorial.RobotData.taskSta)
  return _msg;
}

// int32 heatbeat = 8;
inline void RobotData::clear_heatbeat() {
  heatbeat_ = 0;
}
inline int32_t RobotData::_internal_heatbeat() const {
  return heatbeat_;
}
inline int32_t RobotData::heatbeat() const {
  // @@protoc_insertion_point(field_get:tutorial.RobotData.heatbeat)
  return _internal_heatbeat();
}
inline void RobotData::_internal_set_heatbeat(int32_t value) {
  
  heatbeat_ = value;
}
inline void RobotData::set_heatbeat(int32_t value) {
  _internal_set_heatbeat(value);
  // @@protoc_insertion_point(field_set:tutorial.RobotData.heatbeat)
}

inline bool RobotData::has_Deteil() const {
  return Deteil_case() != DETEIL_NOT_SET;
}
inline void RobotData::clear_has_Deteil() {
  _oneof_case_[0] = DETEIL_NOT_SET;
}
inline RobotData::DeteilCase RobotData::Deteil_case() const {
  return RobotData::DeteilCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// JointState

// repeated float positions = 1;
inline int JointState::_internal_positions_size() const {
  return positions_.size();
}
inline int JointState::positions_size() const {
  return _internal_positions_size();
}
inline void JointState::clear_positions() {
  positions_.Clear();
}
inline float JointState::_internal_positions(int index) const {
  return positions_.Get(index);
}
inline float JointState::positions(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.JointState.positions)
  return _internal_positions(index);
}
inline void JointState::set_positions(int index, float value) {
  positions_.Set(index, value);
  // @@protoc_insertion_point(field_set:tutorial.JointState.positions)
}
inline void JointState::_internal_add_positions(float value) {
  positions_.Add(value);
}
inline void JointState::add_positions(float value) {
  _internal_add_positions(value);
  // @@protoc_insertion_point(field_add:tutorial.JointState.positions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointState::_internal_positions() const {
  return positions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointState::positions() const {
  // @@protoc_insertion_point(field_list:tutorial.JointState.positions)
  return _internal_positions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointState::_internal_mutable_positions() {
  return &positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointState::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.JointState.positions)
  return _internal_mutable_positions();
}

// repeated float velocities = 2;
inline int JointState::_internal_velocities_size() const {
  return velocities_.size();
}
inline int JointState::velocities_size() const {
  return _internal_velocities_size();
}
inline void JointState::clear_velocities() {
  velocities_.Clear();
}
inline float JointState::_internal_velocities(int index) const {
  return velocities_.Get(index);
}
inline float JointState::velocities(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.JointState.velocities)
  return _internal_velocities(index);
}
inline void JointState::set_velocities(int index, float value) {
  velocities_.Set(index, value);
  // @@protoc_insertion_point(field_set:tutorial.JointState.velocities)
}
inline void JointState::_internal_add_velocities(float value) {
  velocities_.Add(value);
}
inline void JointState::add_velocities(float value) {
  _internal_add_velocities(value);
  // @@protoc_insertion_point(field_add:tutorial.JointState.velocities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointState::_internal_velocities() const {
  return velocities_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointState::velocities() const {
  // @@protoc_insertion_point(field_list:tutorial.JointState.velocities)
  return _internal_velocities();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointState::_internal_mutable_velocities() {
  return &velocities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointState::mutable_velocities() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.JointState.velocities)
  return _internal_mutable_velocities();
}

// repeated float accelerations = 3;
inline int JointState::_internal_accelerations_size() const {
  return accelerations_.size();
}
inline int JointState::accelerations_size() const {
  return _internal_accelerations_size();
}
inline void JointState::clear_accelerations() {
  accelerations_.Clear();
}
inline float JointState::_internal_accelerations(int index) const {
  return accelerations_.Get(index);
}
inline float JointState::accelerations(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.JointState.accelerations)
  return _internal_accelerations(index);
}
inline void JointState::set_accelerations(int index, float value) {
  accelerations_.Set(index, value);
  // @@protoc_insertion_point(field_set:tutorial.JointState.accelerations)
}
inline void JointState::_internal_add_accelerations(float value) {
  accelerations_.Add(value);
}
inline void JointState::add_accelerations(float value) {
  _internal_add_accelerations(value);
  // @@protoc_insertion_point(field_add:tutorial.JointState.accelerations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointState::_internal_accelerations() const {
  return accelerations_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointState::accelerations() const {
  // @@protoc_insertion_point(field_list:tutorial.JointState.accelerations)
  return _internal_accelerations();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointState::_internal_mutable_accelerations() {
  return &accelerations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointState::mutable_accelerations() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.JointState.accelerations)
  return _internal_mutable_accelerations();
}

// -------------------------------------------------------------------

// JointTrajectoryPoint

// int32 time = 1;
inline void JointTrajectoryPoint::clear_time() {
  time_ = 0;
}
inline int32_t JointTrajectoryPoint::_internal_time() const {
  return time_;
}
inline int32_t JointTrajectoryPoint::time() const {
  // @@protoc_insertion_point(field_get:tutorial.JointTrajectoryPoint.time)
  return _internal_time();
}
inline void JointTrajectoryPoint::_internal_set_time(int32_t value) {
  
  time_ = value;
}
inline void JointTrajectoryPoint::set_time(int32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:tutorial.JointTrajectoryPoint.time)
}

// repeated float positions = 2;
inline int JointTrajectoryPoint::_internal_positions_size() const {
  return positions_.size();
}
inline int JointTrajectoryPoint::positions_size() const {
  return _internal_positions_size();
}
inline void JointTrajectoryPoint::clear_positions() {
  positions_.Clear();
}
inline float JointTrajectoryPoint::_internal_positions(int index) const {
  return positions_.Get(index);
}
inline float JointTrajectoryPoint::positions(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.JointTrajectoryPoint.positions)
  return _internal_positions(index);
}
inline void JointTrajectoryPoint::set_positions(int index, float value) {
  positions_.Set(index, value);
  // @@protoc_insertion_point(field_set:tutorial.JointTrajectoryPoint.positions)
}
inline void JointTrajectoryPoint::_internal_add_positions(float value) {
  positions_.Add(value);
}
inline void JointTrajectoryPoint::add_positions(float value) {
  _internal_add_positions(value);
  // @@protoc_insertion_point(field_add:tutorial.JointTrajectoryPoint.positions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointTrajectoryPoint::_internal_positions() const {
  return positions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointTrajectoryPoint::positions() const {
  // @@protoc_insertion_point(field_list:tutorial.JointTrajectoryPoint.positions)
  return _internal_positions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointTrajectoryPoint::_internal_mutable_positions() {
  return &positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointTrajectoryPoint::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.JointTrajectoryPoint.positions)
  return _internal_mutable_positions();
}

// repeated float velocities = 3;
inline int JointTrajectoryPoint::_internal_velocities_size() const {
  return velocities_.size();
}
inline int JointTrajectoryPoint::velocities_size() const {
  return _internal_velocities_size();
}
inline void JointTrajectoryPoint::clear_velocities() {
  velocities_.Clear();
}
inline float JointTrajectoryPoint::_internal_velocities(int index) const {
  return velocities_.Get(index);
}
inline float JointTrajectoryPoint::velocities(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.JointTrajectoryPoint.velocities)
  return _internal_velocities(index);
}
inline void JointTrajectoryPoint::set_velocities(int index, float value) {
  velocities_.Set(index, value);
  // @@protoc_insertion_point(field_set:tutorial.JointTrajectoryPoint.velocities)
}
inline void JointTrajectoryPoint::_internal_add_velocities(float value) {
  velocities_.Add(value);
}
inline void JointTrajectoryPoint::add_velocities(float value) {
  _internal_add_velocities(value);
  // @@protoc_insertion_point(field_add:tutorial.JointTrajectoryPoint.velocities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointTrajectoryPoint::_internal_velocities() const {
  return velocities_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointTrajectoryPoint::velocities() const {
  // @@protoc_insertion_point(field_list:tutorial.JointTrajectoryPoint.velocities)
  return _internal_velocities();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointTrajectoryPoint::_internal_mutable_velocities() {
  return &velocities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointTrajectoryPoint::mutable_velocities() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.JointTrajectoryPoint.velocities)
  return _internal_mutable_velocities();
}

// repeated float accelerations = 4;
inline int JointTrajectoryPoint::_internal_accelerations_size() const {
  return accelerations_.size();
}
inline int JointTrajectoryPoint::accelerations_size() const {
  return _internal_accelerations_size();
}
inline void JointTrajectoryPoint::clear_accelerations() {
  accelerations_.Clear();
}
inline float JointTrajectoryPoint::_internal_accelerations(int index) const {
  return accelerations_.Get(index);
}
inline float JointTrajectoryPoint::accelerations(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.JointTrajectoryPoint.accelerations)
  return _internal_accelerations(index);
}
inline void JointTrajectoryPoint::set_accelerations(int index, float value) {
  accelerations_.Set(index, value);
  // @@protoc_insertion_point(field_set:tutorial.JointTrajectoryPoint.accelerations)
}
inline void JointTrajectoryPoint::_internal_add_accelerations(float value) {
  accelerations_.Add(value);
}
inline void JointTrajectoryPoint::add_accelerations(float value) {
  _internal_add_accelerations(value);
  // @@protoc_insertion_point(field_add:tutorial.JointTrajectoryPoint.accelerations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointTrajectoryPoint::_internal_accelerations() const {
  return accelerations_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointTrajectoryPoint::accelerations() const {
  // @@protoc_insertion_point(field_list:tutorial.JointTrajectoryPoint.accelerations)
  return _internal_accelerations();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointTrajectoryPoint::_internal_mutable_accelerations() {
  return &accelerations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointTrajectoryPoint::mutable_accelerations() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.JointTrajectoryPoint.accelerations)
  return _internal_mutable_accelerations();
}

// -------------------------------------------------------------------

// JointTrajectory

// int32 count = 1;
inline void JointTrajectory::clear_count() {
  count_ = 0;
}
inline int32_t JointTrajectory::_internal_count() const {
  return count_;
}
inline int32_t JointTrajectory::count() const {
  // @@protoc_insertion_point(field_get:tutorial.JointTrajectory.count)
  return _internal_count();
}
inline void JointTrajectory::_internal_set_count(int32_t value) {
  
  count_ = value;
}
inline void JointTrajectory::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:tutorial.JointTrajectory.count)
}

// repeated .tutorial.JointTrajectoryPoint points = 2;
inline int JointTrajectory::_internal_points_size() const {
  return points_.size();
}
inline int JointTrajectory::points_size() const {
  return _internal_points_size();
}
inline void JointTrajectory::clear_points() {
  points_.Clear();
}
inline ::tutorial::JointTrajectoryPoint* JointTrajectory::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.JointTrajectory.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::JointTrajectoryPoint >*
JointTrajectory::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.JointTrajectory.points)
  return &points_;
}
inline const ::tutorial::JointTrajectoryPoint& JointTrajectory::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::tutorial::JointTrajectoryPoint& JointTrajectory::points(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.JointTrajectory.points)
  return _internal_points(index);
}
inline ::tutorial::JointTrajectoryPoint* JointTrajectory::_internal_add_points() {
  return points_.Add();
}
inline ::tutorial::JointTrajectoryPoint* JointTrajectory::add_points() {
  ::tutorial::JointTrajectoryPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:tutorial.JointTrajectory.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::JointTrajectoryPoint >&
JointTrajectory::points() const {
  // @@protoc_insertion_point(field_list:tutorial.JointTrajectory.points)
  return points_;
}

// -------------------------------------------------------------------

// TaskCommandItem

// string robotName = 1;
inline void TaskCommandItem::clear_robotname() {
  robotname_.ClearToEmpty();
}
inline const std::string& TaskCommandItem::robotname() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.robotName)
  return _internal_robotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskCommandItem::set_robotname(ArgT0&& arg0, ArgT... args) {
 
 robotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.robotName)
}
inline std::string* TaskCommandItem::mutable_robotname() {
  std::string* _s = _internal_mutable_robotname();
  // @@protoc_insertion_point(field_mutable:tutorial.TaskCommandItem.robotName)
  return _s;
}
inline const std::string& TaskCommandItem::_internal_robotname() const {
  return robotname_.Get();
}
inline void TaskCommandItem::_internal_set_robotname(const std::string& value) {
  
  robotname_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskCommandItem::_internal_mutable_robotname() {
  
  return robotname_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskCommandItem::release_robotname() {
  // @@protoc_insertion_point(field_release:tutorial.TaskCommandItem.robotName)
  return robotname_.Release();
}
inline void TaskCommandItem::set_allocated_robotname(std::string* robotname) {
  if (robotname != nullptr) {
    
  } else {
    
  }
  robotname_.SetAllocated(robotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robotname_.IsDefault()) {
    robotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.TaskCommandItem.robotName)
}

// int32 task_num = 2;
inline void TaskCommandItem::clear_task_num() {
  task_num_ = 0;
}
inline int32_t TaskCommandItem::_internal_task_num() const {
  return task_num_;
}
inline int32_t TaskCommandItem::task_num() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.task_num)
  return _internal_task_num();
}
inline void TaskCommandItem::_internal_set_task_num(int32_t value) {
  
  task_num_ = value;
}
inline void TaskCommandItem::set_task_num(int32_t value) {
  _internal_set_task_num(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.task_num)
}

// float startX = 3;
inline void TaskCommandItem::clear_startx() {
  startx_ = 0;
}
inline float TaskCommandItem::_internal_startx() const {
  return startx_;
}
inline float TaskCommandItem::startx() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.startX)
  return _internal_startx();
}
inline void TaskCommandItem::_internal_set_startx(float value) {
  
  startx_ = value;
}
inline void TaskCommandItem::set_startx(float value) {
  _internal_set_startx(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.startX)
}

// float startY = 4;
inline void TaskCommandItem::clear_starty() {
  starty_ = 0;
}
inline float TaskCommandItem::_internal_starty() const {
  return starty_;
}
inline float TaskCommandItem::starty() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.startY)
  return _internal_starty();
}
inline void TaskCommandItem::_internal_set_starty(float value) {
  
  starty_ = value;
}
inline void TaskCommandItem::set_starty(float value) {
  _internal_set_starty(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.startY)
}

// float startZ = 5;
inline void TaskCommandItem::clear_startz() {
  startz_ = 0;
}
inline float TaskCommandItem::_internal_startz() const {
  return startz_;
}
inline float TaskCommandItem::startz() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.startZ)
  return _internal_startz();
}
inline void TaskCommandItem::_internal_set_startz(float value) {
  
  startz_ = value;
}
inline void TaskCommandItem::set_startz(float value) {
  _internal_set_startz(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.startZ)
}

// float goalX = 6;
inline void TaskCommandItem::clear_goalx() {
  goalx_ = 0;
}
inline float TaskCommandItem::_internal_goalx() const {
  return goalx_;
}
inline float TaskCommandItem::goalx() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.goalX)
  return _internal_goalx();
}
inline void TaskCommandItem::_internal_set_goalx(float value) {
  
  goalx_ = value;
}
inline void TaskCommandItem::set_goalx(float value) {
  _internal_set_goalx(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.goalX)
}

// float goalY = 7;
inline void TaskCommandItem::clear_goaly() {
  goaly_ = 0;
}
inline float TaskCommandItem::_internal_goaly() const {
  return goaly_;
}
inline float TaskCommandItem::goaly() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.goalY)
  return _internal_goaly();
}
inline void TaskCommandItem::_internal_set_goaly(float value) {
  
  goaly_ = value;
}
inline void TaskCommandItem::set_goaly(float value) {
  _internal_set_goaly(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.goalY)
}

// float goalZ = 8;
inline void TaskCommandItem::clear_goalz() {
  goalz_ = 0;
}
inline float TaskCommandItem::_internal_goalz() const {
  return goalz_;
}
inline float TaskCommandItem::goalz() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.goalZ)
  return _internal_goalz();
}
inline void TaskCommandItem::_internal_set_goalz(float value) {
  
  goalz_ = value;
}
inline void TaskCommandItem::set_goalz(float value) {
  _internal_set_goalz(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.goalZ)
}

// float goal7 = 9;
inline void TaskCommandItem::clear_goal7() {
  goal7_ = 0;
}
inline float TaskCommandItem::_internal_goal7() const {
  return goal7_;
}
inline float TaskCommandItem::goal7() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommandItem.goal7)
  return _internal_goal7();
}
inline void TaskCommandItem::_internal_set_goal7(float value) {
  
  goal7_ = value;
}
inline void TaskCommandItem::set_goal7(float value) {
  _internal_set_goal7(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskCommandItem.goal7)
}

// -------------------------------------------------------------------

// TaskCommand

// repeated .tutorial.TaskCommandItem items = 1;
inline int TaskCommand::_internal_items_size() const {
  return items_.size();
}
inline int TaskCommand::items_size() const {
  return _internal_items_size();
}
inline void TaskCommand::clear_items() {
  items_.Clear();
}
inline ::tutorial::TaskCommandItem* TaskCommand::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.TaskCommand.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::TaskCommandItem >*
TaskCommand::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.TaskCommand.items)
  return &items_;
}
inline const ::tutorial::TaskCommandItem& TaskCommand::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::tutorial::TaskCommandItem& TaskCommand::items(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.TaskCommand.items)
  return _internal_items(index);
}
inline ::tutorial::TaskCommandItem* TaskCommand::_internal_add_items() {
  return items_.Add();
}
inline ::tutorial::TaskCommandItem* TaskCommand::add_items() {
  ::tutorial::TaskCommandItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:tutorial.TaskCommand.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::TaskCommandItem >&
TaskCommand::items() const {
  // @@protoc_insertion_point(field_list:tutorial.TaskCommand.items)
  return items_;
}

// -------------------------------------------------------------------

// TaskOder

// string robotName = 1;
inline void TaskOder::clear_robotname() {
  robotname_.ClearToEmpty();
}
inline const std::string& TaskOder::robotname() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskOder.robotName)
  return _internal_robotname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskOder::set_robotname(ArgT0&& arg0, ArgT... args) {
 
 robotname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.TaskOder.robotName)
}
inline std::string* TaskOder::mutable_robotname() {
  std::string* _s = _internal_mutable_robotname();
  // @@protoc_insertion_point(field_mutable:tutorial.TaskOder.robotName)
  return _s;
}
inline const std::string& TaskOder::_internal_robotname() const {
  return robotname_.Get();
}
inline void TaskOder::_internal_set_robotname(const std::string& value) {
  
  robotname_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskOder::_internal_mutable_robotname() {
  
  return robotname_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskOder::release_robotname() {
  // @@protoc_insertion_point(field_release:tutorial.TaskOder.robotName)
  return robotname_.Release();
}
inline void TaskOder::set_allocated_robotname(std::string* robotname) {
  if (robotname != nullptr) {
    
  } else {
    
  }
  robotname_.SetAllocated(robotname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (robotname_.IsDefault()) {
    robotname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.TaskOder.robotName)
}

// bool stopoder = 2;
inline void TaskOder::clear_stopoder() {
  stopoder_ = false;
}
inline bool TaskOder::_internal_stopoder() const {
  return stopoder_;
}
inline bool TaskOder::stopoder() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskOder.stopoder)
  return _internal_stopoder();
}
inline void TaskOder::_internal_set_stopoder(bool value) {
  
  stopoder_ = value;
}
inline void TaskOder::set_stopoder(bool value) {
  _internal_set_stopoder(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskOder.stopoder)
}

// bool runoder = 3;
inline void TaskOder::clear_runoder() {
  runoder_ = false;
}
inline bool TaskOder::_internal_runoder() const {
  return runoder_;
}
inline bool TaskOder::runoder() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskOder.runoder)
  return _internal_runoder();
}
inline void TaskOder::_internal_set_runoder(bool value) {
  
  runoder_ = value;
}
inline void TaskOder::set_runoder(bool value) {
  _internal_set_runoder(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskOder.runoder)
}

// bool testoder = 4;
inline void TaskOder::clear_testoder() {
  testoder_ = false;
}
inline bool TaskOder::_internal_testoder() const {
  return testoder_;
}
inline bool TaskOder::testoder() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskOder.testoder)
  return _internal_testoder();
}
inline void TaskOder::_internal_set_testoder(bool value) {
  
  testoder_ = value;
}
inline void TaskOder::set_testoder(bool value) {
  _internal_set_testoder(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskOder.testoder)
}

// -------------------------------------------------------------------

// TaskStatus

// int32 task_num = 1;
inline void TaskStatus::clear_task_num() {
  task_num_ = 0;
}
inline int32_t TaskStatus::_internal_task_num() const {
  return task_num_;
}
inline int32_t TaskStatus::task_num() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskStatus.task_num)
  return _internal_task_num();
}
inline void TaskStatus::_internal_set_task_num(int32_t value) {
  
  task_num_ = value;
}
inline void TaskStatus::set_task_num(int32_t value) {
  _internal_set_task_num(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskStatus.task_num)
}

// .tutorial.STATUS status = 2;
inline void TaskStatus::clear_status() {
  status_ = 0;
}
inline ::tutorial::STATUS TaskStatus::_internal_status() const {
  return static_cast< ::tutorial::STATUS >(status_);
}
inline ::tutorial::STATUS TaskStatus::status() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskStatus.status)
  return _internal_status();
}
inline void TaskStatus::_internal_set_status(::tutorial::STATUS value) {
  
  status_ = value;
}
inline void TaskStatus::set_status(::tutorial::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskStatus.status)
}

// int32 device_num = 3;
inline void TaskStatus::clear_device_num() {
  device_num_ = 0;
}
inline int32_t TaskStatus::_internal_device_num() const {
  return device_num_;
}
inline int32_t TaskStatus::device_num() const {
  // @@protoc_insertion_point(field_get:tutorial.TaskStatus.device_num)
  return _internal_device_num();
}
inline void TaskStatus::_internal_set_device_num(int32_t value) {
  
  device_num_ = value;
}
inline void TaskStatus::set_device_num(int32_t value) {
  _internal_set_device_num(value);
  // @@protoc_insertion_point(field_set:tutorial.TaskStatus.device_num)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tutorial

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tutorial::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::MsgType>() {
  return ::tutorial::MsgType_descriptor();
}
template <> struct is_proto_enum< ::tutorial::STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::STATUS>() {
  return ::tutorial::STATUS_descriptor();
}
template <> struct is_proto_enum< ::tutorial::DEVICE_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::DEVICE_STATUS>() {
  return ::tutorial::DEVICE_STATUS_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_JointState_2eproto
